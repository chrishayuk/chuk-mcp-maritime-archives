"""
VOC Routes — standard sailing routes of the Dutch East India Company.

Defines the major VOC shipping routes as sequences of waypoints with
typical sailing durations between them.  Durations are based on
historical averages from the DAS database (Bruijn, Gaastra & Schoffer,
*Dutch-Asiatic Shipping*, 1987).

Key feature: ``estimate_position()`` interpolates a ship's likely
position on a given date based on its departure date and intended route.
An LLM can use this when investigating wrecks or lost voyages.

Typical usage by an LLM:
    1. Read a voyage's departure_date, departure_port, destination_port
    2. Call ``maritime_get_route`` to see the standard waypoints
    3. Call ``maritime_estimate_position`` with a target date to see
       where the ship probably was when it was lost

Data is loaded from ``data/routes.json`` (generated by
``scripts/generate_reference.py``).

Sources & references:
    - Bruijn, Gaastra & Schoffer, *Dutch-Asiatic Shipping* (1987)
    - DAS database: https://resources.huygens.knaw.nl/das
    - CLIWOC (ship logbook data, 1750-1854): https://www.historicalclimatology.com/cliwoc.html
    - CLIWOC Routes (Figshare): https://figshare.com/articles/dataset/CLIWOC_Slim_and_Routes/11941224
    - Brouwer Route (outer route via Roaring Forties, adopted 1611)
"""

from __future__ import annotations

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Any

logger = logging.getLogger(__name__)

_DEFAULT_DATA_DIR = Path(__file__).resolve().parent.parent.parent.parent / "data"

# Loaded from JSON: {route_id: {name, description, direction, ...waypoints...}}
VOC_ROUTES: dict[str, dict[str, Any]] = {}


# ---------------------------------------------------------------------------
# Data loading
# ---------------------------------------------------------------------------


def _load_routes(data_dir: Path | None = None) -> None:
    """Load route data from JSON file."""
    global VOC_ROUTES
    if VOC_ROUTES:
        return

    path = (data_dir or _DEFAULT_DATA_DIR) / "routes.json"
    if not path.exists():
        logger.warning("Routes not found: %s (run scripts/generate_reference.py)", path)
        return

    with open(path) as f:
        entries = json.load(f)

    for entry in entries:
        route_id = entry.pop("route_id")
        VOC_ROUTES[route_id] = entry

    logger.info("Loaded %d routes from %s", len(VOC_ROUTES), path.name)


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------


def list_routes() -> list[dict[str, Any]]:
    """Return summary list of all available routes."""
    _load_routes()
    results = []
    for route_id, route in VOC_ROUTES.items():
        results.append(
            {
                "route_id": route_id,
                "name": route["name"],
                "direction": route["direction"],
                "typical_duration_days": route["typical_duration_days"],
                "waypoint_count": len(route["waypoints"]),
            }
        )
    return results


def get_route(route_id: str) -> dict[str, Any] | None:
    """Return full route details including waypoints."""
    _load_routes()
    route = VOC_ROUTES.get(route_id)
    if route is None:
        return None
    return {"route_id": route_id, **route}


def get_route_ids() -> list[str]:
    """Return available route identifiers."""
    _load_routes()
    return list(VOC_ROUTES.keys())


def estimate_position(
    route_id: str,
    departure_date: str,
    target_date: str,
) -> dict[str, Any] | None:
    """
    Estimate a ship's position on a given date based on the standard route.

    Uses linear interpolation between waypoints based on the typical
    cumulative sailing days for that route.

    Args:
        route_id: Route identifier (e.g., "outward_outer")
        departure_date: Departure date as YYYY-MM-DD
        target_date: Date to estimate position for as YYYY-MM-DD

    Returns:
        Dict with estimated position, segment info, and confidence notes,
        or None if route not found.
    """
    _load_routes()
    route = VOC_ROUTES.get(route_id)
    if route is None:
        return None

    try:
        dep = datetime.strptime(departure_date, "%Y-%m-%d")
        target = datetime.strptime(target_date, "%Y-%m-%d")
    except ValueError:
        return None

    elapsed_days = (target - dep).days
    if elapsed_days < 0:
        return {
            "error": "Target date is before departure date",
            "departure_date": departure_date,
            "target_date": target_date,
        }

    waypoints = route["waypoints"]
    total_days = waypoints[-1]["cumulative_days"]

    # Before first waypoint
    if elapsed_days == 0:
        wp = waypoints[0]
        return _build_estimate(
            route_id=route_id,
            route_name=route["name"],
            departure_date=departure_date,
            target_date=target_date,
            elapsed_days=elapsed_days,
            total_days=total_days,
            lat=wp["lat"],
            lon=wp["lon"],
            region=wp["region"],
            segment_from=wp["name"],
            segment_to=wp["name"],
            segment_progress=0.0,
            confidence="high",
            notes=f"At departure point: {wp['name']}",
        )

    # After last waypoint
    if elapsed_days >= total_days:
        wp = waypoints[-1]
        days_over = elapsed_days - total_days
        return _build_estimate(
            route_id=route_id,
            route_name=route["name"],
            departure_date=departure_date,
            target_date=target_date,
            elapsed_days=elapsed_days,
            total_days=total_days,
            lat=wp["lat"],
            lon=wp["lon"],
            region=wp["region"],
            segment_from=wp["name"],
            segment_to=wp["name"],
            segment_progress=1.0,
            confidence="low" if days_over > 30 else "moderate",
            notes=(
                f"Ship should have arrived at {wp['name']} by day {total_days}. "
                f"Target is {days_over} days past expected arrival."
            ),
        )

    # Find the two bounding waypoints
    for i in range(len(waypoints) - 1):
        wp_a = waypoints[i]
        wp_b = waypoints[i + 1]
        day_a = wp_a["cumulative_days"]
        day_b = wp_b["cumulative_days"]

        # Account for stop time at waypoint A
        stop = wp_a.get("stop_days", 0)
        if day_a <= elapsed_days <= day_a + stop:
            return _build_estimate(
                route_id=route_id,
                route_name=route["name"],
                departure_date=departure_date,
                target_date=target_date,
                elapsed_days=elapsed_days,
                total_days=total_days,
                lat=wp_a["lat"],
                lon=wp_a["lon"],
                region=wp_a["region"],
                segment_from=wp_a["name"],
                segment_to=wp_a["name"],
                segment_progress=0.0,
                confidence="high",
                notes=f"Likely at port: {wp_a['name']} ({wp_a.get('notes', '')})",
            )

        effective_day_a = day_a + stop
        if effective_day_a <= elapsed_days <= day_b:
            # Interpolate between waypoints
            segment_duration = day_b - effective_day_a
            if segment_duration == 0:
                progress = 1.0
            else:
                progress = (elapsed_days - effective_day_a) / segment_duration

            lat = wp_a["lat"] + progress * (wp_b["lat"] - wp_a["lat"])
            lon = wp_a["lon"] + progress * (wp_b["lon"] - wp_a["lon"])

            # Determine region (use source region in first half, dest in second)
            region = wp_a["region"] if progress < 0.5 else wp_b["region"]

            return _build_estimate(
                route_id=route_id,
                route_name=route["name"],
                departure_date=departure_date,
                target_date=target_date,
                elapsed_days=elapsed_days,
                total_days=total_days,
                lat=round(lat, 2),
                lon=round(lon, 2),
                region=region,
                segment_from=wp_a["name"],
                segment_to=wp_b["name"],
                segment_progress=round(progress, 2),
                confidence="moderate",
                notes=(
                    f"Estimated between {wp_a['name']} and {wp_b['name']}. "
                    f"Position is approximate — actual speed varied with "
                    f"wind and weather."
                ),
            )

    return None


def suggest_route(
    departure_port: str | None = None,
    destination_port: str | None = None,
    direction: str | None = None,
) -> list[dict[str, Any]]:
    """
    Suggest likely routes based on ports or direction.

    Returns matching routes as summary dicts.
    """
    _load_routes()
    results = []
    dep_lower = (departure_port or "").lower()
    dest_lower = (destination_port or "").lower()

    for route_id, route in VOC_ROUTES.items():
        if direction and route["direction"] != direction:
            continue

        waypoints = route["waypoints"]
        wp_names = [wp["name"].lower() for wp in waypoints]

        if dep_lower and not any(dep_lower in n for n in wp_names):
            continue
        if dest_lower and not any(dest_lower in n for n in wp_names):
            continue

        results.append(
            {
                "route_id": route_id,
                "name": route["name"],
                "direction": route["direction"],
                "typical_duration_days": route["typical_duration_days"],
                "waypoint_count": len(waypoints),
            }
        )

    return results


# ---------------------------------------------------------------------------
# Private helpers
# ---------------------------------------------------------------------------


def _build_estimate(
    *,
    route_id: str,
    route_name: str,
    departure_date: str,
    target_date: str,
    elapsed_days: int,
    total_days: int,
    lat: float,
    lon: float,
    region: str,
    segment_from: str,
    segment_to: str,
    segment_progress: float,
    confidence: str,
    notes: str,
) -> dict[str, Any]:
    """Build a standard position estimate result dict."""
    return {
        "route_id": route_id,
        "route_name": route_name,
        "departure_date": departure_date,
        "target_date": target_date,
        "elapsed_days": elapsed_days,
        "total_route_days": total_days,
        "voyage_progress": round(min(elapsed_days / total_days, 1.0), 2),
        "estimated_position": {
            "lat": lat,
            "lon": lon,
            "region": region,
        },
        "segment": {
            "from": segment_from,
            "to": segment_to,
            "progress": segment_progress,
        },
        "confidence": confidence,
        "notes": notes,
        "caveats": [
            "Position is based on TYPICAL sailing times and may vary significantly",
            "Actual speed depended on wind, currents, ship condition, and weather",
            "Stop durations at ports varied (resupply, repairs, waiting for convoys)",
            "Ships sometimes deviated from standard routes due to storms or orders",
        ],
    }


# Load on import
_load_routes()
