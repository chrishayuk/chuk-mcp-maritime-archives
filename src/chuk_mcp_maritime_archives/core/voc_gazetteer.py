"""
VOC Gazetteer — historical place-name lookup for maritime archives.

Maps ~170 place names from the VOC era to modern coordinates, region
classification (matching ``constants.REGIONS``), and historical context.

Data is loaded from ``data/gazetteer.json`` (generated by
``scripts/generate_reference.py``).

This is designed as an MCP tool so that an LLM can:
1. Read the ``particulars`` text from a voyage or wreck record
2. Identify place names mentioned in that text
3. Call ``maritime_lookup_location`` to get coordinates and region
"""

from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import Any

logger = logging.getLogger(__name__)

_DEFAULT_DATA_DIR = Path(__file__).resolve().parent.parent.parent.parent / "data"

# Loaded from JSON: {name: {lat, lon, region, type, aliases, notes}}
VOC_GAZETTEER: dict[str, dict[str, Any]] = {}

# Alias index: lowercase alias/name -> canonical name
_ALIAS_INDEX: dict[str, str] = {}


# ---------------------------------------------------------------------------
# Data loading
# ---------------------------------------------------------------------------


def _load_gazetteer(data_dir: Path | None = None) -> None:
    """Load gazetteer data from JSON file."""
    global VOC_GAZETTEER, _ALIAS_INDEX
    if VOC_GAZETTEER:
        return

    path = (data_dir or _DEFAULT_DATA_DIR) / "gazetteer.json"
    if not path.exists():
        logger.warning("Gazetteer not found: %s (run scripts/generate_reference.py)", path)
        return

    with open(path) as f:
        entries = json.load(f)

    for entry in entries:
        name = entry.pop("name")
        VOC_GAZETTEER[name] = entry

    _build_alias_index()
    logger.info("Loaded %d gazetteer entries from %s", len(VOC_GAZETTEER), path.name)


def _build_alias_index() -> None:
    """Build a lowercase alias -> canonical name lookup table."""
    global _ALIAS_INDEX
    _ALIAS_INDEX = {}
    for name, entry in VOC_GAZETTEER.items():
        _ALIAS_INDEX[name.lower()] = name
        for alias in entry.get("aliases", []):
            _ALIAS_INDEX[alias.lower()] = name


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------


def lookup_location(query: str) -> dict[str, Any] | None:
    """
    Look up a place name in the VOC gazetteer.

    Tries exact match first, then alias match, then substring match.
    Returns the gazetteer entry with the canonical name added, or None.
    """
    _load_gazetteer()

    if not query or not query.strip():
        return None

    query_clean = query.strip()
    query_lower = query_clean.lower()

    # Exact or alias match
    canonical = _ALIAS_INDEX.get(query_lower)
    if canonical:
        entry = VOC_GAZETTEER[canonical]
        return {"name": canonical, **entry}

    # Substring match — find the best (shortest name that contains query)
    matches = []
    for name in VOC_GAZETTEER:
        if query_lower in name.lower():
            matches.append(name)
    for alias, canonical_name in _ALIAS_INDEX.items():
        if query_lower in alias and canonical_name not in matches:
            matches.append(canonical_name)

    if matches:
        # Return the shortest match (most specific)
        best = min(matches, key=len)
        entry = VOC_GAZETTEER[best]
        return {"name": best, **entry}

    return None


def search_locations(
    query: str | None = None,
    region: str | None = None,
    location_type: str | None = None,
    max_results: int = 50,
) -> list[dict[str, Any]]:
    """
    Search the VOC gazetteer with optional filters.

    Args:
        query: Text to match against name or aliases (substring, case-insensitive)
        region: Filter by region key (e.g., "indonesia", "cape")
        location_type: Filter by type (e.g., "port", "island", "cape")
        max_results: Maximum results to return
    """
    _load_gazetteer()
    results = []

    for name, entry in VOC_GAZETTEER.items():
        if region and entry.get("region") != region:
            continue
        if location_type and entry.get("type") != location_type:
            continue
        if query:
            q = query.lower()
            name_match = q in name.lower()
            alias_match = any(q in a.lower() for a in entry.get("aliases", []))
            notes_match = q in (entry.get("notes", "")).lower()
            if not (name_match or alias_match or notes_match):
                continue
        results.append({"name": name, **entry})

    return results[:max_results]


def list_regions() -> dict[str, int]:
    """Return region keys with counts of locations in each."""
    _load_gazetteer()
    counts: dict[str, int] = {}
    for entry in VOC_GAZETTEER.values():
        r = entry.get("region", "unknown")
        counts[r] = counts.get(r, 0) + 1
    return dict(sorted(counts.items()))


def list_location_types() -> dict[str, int]:
    """Return location types with counts."""
    _load_gazetteer()
    counts: dict[str, int] = {}
    for entry in VOC_GAZETTEER.values():
        t = entry.get("type", "unknown")
        counts[t] = counts.get(t, 0) + 1
    return dict(sorted(counts.items()))


# Load on import
_load_gazetteer()
